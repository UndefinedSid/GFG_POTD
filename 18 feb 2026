Problem link --> https://www.geeksforgeeks.org/problems/inversion-of-array-1587115620/1

// C++ code

class Solution {
public:
    // Helper function to merge and count inversions
    long long mergeAndCount(vector<long long>& arr, vector<long long>& temp, int left, int mid, int right) {
        int i = left;      
        int j = mid + 1;   
        int k = left;      
        long long invCount = 0;

        while (i <= mid && j <= right) {
            if (arr[i] <= arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
                invCount += (mid - i + 1); 
            }
        }

        while (i <= mid) temp[k++] = arr[i++];
        while (j <= right) temp[k++] = arr[j++];

        for (i = left; i <= right; i++) arr[i] = temp[i];

        return invCount;
    }

    long long mergeSortAndCount(vector<long long>& arr, vector<long long>& temp, int left, int right) {
        long long invCount = 0;
        if (left < right) {
            int mid = left + (right - left) / 2;
            invCount += mergeSortAndCount(arr, temp, left, mid);
            invCount += mergeSortAndCount(arr, temp, mid + 1, right);
            invCount += mergeAndCount(arr, temp, left, mid, right);
        }
        return invCount;
    }

    // This matches the signature the Driver.cpp is looking for
    long long inversionCount(vector<int> &arr) {
        int n = arr.size();
        // Convert int vector to long long to prevent overflow during calculations
        vector<long long> copyArr(arr.begin(), arr.end());
        vector<long long> temp(n);
        return mergeSortAndCount(copyArr, temp, 0, n - 1);
    }
};


// Python code

from typing import List
class Solution:
    def mergeAndCount(self, arr: List[int], temp: List[int], left: int, mid: int, right: int) -> int:
        i = left
        j = mid + 1
        k = left
        invCount = 0

        while i <= mid and j <= right:
            if arr[i] <= arr[j]:
                temp[k] = arr[i]
                i += 1
                k += 1
            else:
                temp[k] = arr[j]
                j += 1
                k += 1
                invCount += (mid - i + 1)

        while i <= mid:
            temp[k] = arr[i]
            i += 1
            k += 1

        while j <= right:
            temp[k] = arr[j]
            j += 1
            k += 1

        for i in range(left, right + 1):
            arr[i] = temp[i]

        return invCount

    def mergeSortAndCount(self, arr: List[int], temp: List[int], left: int, right: int) -> int:
        invCount = 0
        if left < right:
            mid = left + (right - left) // 2
            invCount += self.mergeSortAndCount(arr, temp, left, mid)
            invCount += self.mergeSortAndCount(arr, temp, mid + 1, right)
            invCount += self.mergeAndCount(arr, temp, left, mid, right)
        return invCount

    def inversionCount(self, arr: List[int]) -> int:
        n = len(arr)
        copyArr = list(arr)  # copy to avoid modifying original
        temp = [0] * n
        return self.mergeSortAndCount(copyArr, temp, 0, n - 1)
